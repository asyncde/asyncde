/**
 This file is a part of the AsyncDE library.

 If you are using AsyncDE as part of your research, teaching,
 or other activities, we would be grateful if you could cite our work:
 Zhabitskaya, E., Zhabitsky, M. (2013).
 Asynchronous Differential Evolution with Restart.
 In: Dimov, I., Farag√≥, I., Vulkov, L. (eds) Numerical Analysis and Its
 Applications. NAA 2012. Lecture Notes in Computer Science, vol 8236. Springer,
 Berlin, Heidelberg. https://doi.org/10.1007/978-3-642-41515-9_64

 The AsyncDE library is free software.
 You can redistribute it and/or modify it under the terms
 of the GNU Lesser General Public License as published
 by the Free Software Foundation; either version 3 of the License, or
 (at your option) any later version.
 see https://www.gnu.org/licenses/.
*/

#ifndef ASYNCDE_ADECONFIG_H
#define ASYNCDE_ADECONFIG_H

#include <stdio.h>
#include <string>

#include "asyncde/IteratorConfig.h"

namespace asyncde {

#define ADE_VECTORS                                                            \
  ADE_VECTOR(RAND, "rand")                                                     \
  ADE_VECTOR(ARAND, "arand")                                                   \
  ADE_VECTOR(BEST, "best")                                                     \
  ADE_VECTOR(WORST, "worst")                                                   \
  ADE_VECTOR(LINBEST, "linbest")                                               \
  ADE_VECTOR(LINWORST, "linworst")                                             \
  ADE_VECTOR(PWORST, "pworst")                                                 \
  ADE_VECTOR(RANDTOBEST, "rand-to-best")                                       \
  ADE_VECTOR(CURRENTTORAND, "current-to-rand")                                 \
  ADE_VECTOR(TARGETTORAND, "target-to-rand")                                   \
  ADE_VECTOR(CURRENTTOBEST, "current-to-best")                                 \
  ADE_VECTOR(TARGETTOBEST, "target-to-best")                                   \
  ADE_VECTOR(CURRENTTOPBEST, "current-to-pbest")                               \
  ADE_VECTOR(TARGETTOPBEST, "target-to-pbest")

enum {
#undef ADE_VECTOR
#define ADE_VECTOR(ID, NAME) ADE_VECTOR_##ID,

  ADE_VECTORS
};

#define ADE_CROSSOVER_TYPES                                                    \
  ADE_CROSSOVER(UNDEFINED, "undefined")                                        \
  ADE_CROSSOVER(BIN, "bin")                                                    \
  ADE_CROSSOVER(SCM, "scm")                                                    \
  ADE_CROSSOVER(ACM, "acm")

enum ade_crossover_types {
#undef ADE_CROSSOVER
#define ADE_CROSSOVER(ID, NAME) ADE_CROSSOVER_##ID,

  ADE_CROSSOVER_TYPES
};

enum ade_crossover_update_types {
  ADE_CROSSOVER_UPDATE_Cauchy = 0,
  ADE_CROSSOVER_UPDATE_jDE,
  ADE_CROSSOVER_UPDATE_JADE,
  ADE_CROSSOVER_UPDATE_ACM,
  ADE_CROSSOVER_UPDATE_NTYPES
};

enum ade_fscale_types {
  ADE_FSCALE_Cauchy = 0,
  ADE_FSCALE_jDE,
  ADE_FSCALE_JADE,
  ADE_FSCALE_NTYPES
};

enum ade_mutant_vector_unique_types {
  ADE_MVECTOR_UNIQUE_NOTEST = 0,
  ADE_MVECTOR_DIFF_TARGET,
  ADE_MVECTOR_UNIQUE_INPOP,
  ADE_MVECTOR_UNIQUE_NTYPES
};

enum ade_selection_types {
  ADE_SELECTION_PARENT = 0, // (1+1)-ES: compare to the parent
  ADE_SELECTION_RANDOM,     // (1+1)-ES: compare to a random population member
  ADE_SELECTION_WORST,      // (Np+1)-ES: compare to the worst population member
  ADE_SELECTION_NTYPES
};

class ADEConfig : public IteratorConfig {
protected:
  /// size of an initial population
  unsigned int minpopsize;

public:
  int targetvector; // as defined by strategy
  int basevector;   // as defined by strategy
  unsigned int ndifferences;
  ade_fscale_types Fscaletype;
  double Fmin;
  double Fmax;
  double tauF; // if rand() > tauF use historic value, otherwise generate new F
  double Fmu;
  double Fsigma;
  double Fc; // learning rate: Fmu{i+1} = (1 - Fc)Fmu{i} + Fc<F>{i}
  ade_crossover_types crossovertype;
  ade_crossover_update_types CRupdatetype;
  double CRmin;
  double CRmax;
  double
      tauCR; // if rand() > tauCR use historic value, otherwise generate new CR
  double CRmu;
  double CRsigma;
  double CRc;     // learning rate: CRmu{i+1} = (1 - CRc)CRmu{i} + CRc<CR>{i}
  double tauCorr; // if rand() > tauCorr use historic value, otherwise generate
                  // new threshold
  double wCmin;  // C{g+1} = (1 - wC)C{g} + wC*SCM{g+1}
  double pbest;   // (0, 1]: part of population in current-to-pbest strategy
  double pworst;  // (0, 1]: part of population in pworst strategy
  double pcorr_reliable; // [0,1] minimal part of population generated by ADE
                         // operators

  ade_selection_types selectiontype;

  int archive;
  double archivesizefactor; // size of archive =  archivesizefactor * size of
                            // current population
  ade_mutant_vector_unique_types mvector_unique;

protected:
  void Init() {
    targetvector = ADE_VECTOR_RAND;
    basevector = ADE_VECTOR_RAND;
    ndifferences = 1;
    Fscaletype = ADE_FSCALE_Cauchy;
    Fmin = 0.1;
    Fmax = 0.99;
    tauF = 0.1;
    Fmu = 0.9;
    Fsigma = 0.1;
    Fc = 0.01;

    crossovertype = ADE_CROSSOVER_ACM;
    CRupdatetype = ADE_CROSSOVER_UPDATE_ACM;
    CRmin = 0.0;
    CRmax = 1.0;
    tauCR = 0.1;
    CRmu = 0.5;
    CRsigma = 0.1;
    CRc = Fc;
    tauCorr = 1.0;
    wCmin = 0.01;
    pbest = 0.1;
    pworst = 0.1;
    pcorr_reliable = 0.5;

    selectiontype = ADE_SELECTION_PARENT;

    archive = 0;
    archivesizefactor = 1.0;
    mvector_unique = ADE_MVECTOR_DIFF_TARGET;

    if (minpopsize < MinimalADEPopulationSize())
      minpopsize = MinimalADEPopulationSize();
  }

public:
  ADEConfig(Rnd *_rnd, unsigned int _minpopsize)
      : IteratorConfig(_rnd), minpopsize(_minpopsize) {
    Init();
  }

  virtual ~ADEConfig() {}

  virtual void Reset(unsigned int _minpopsize) override {
    IteratorConfig::Reset(_minpopsize);
    Init();
  }

  virtual AsyncIterator *NewIterator(const Problem &_problem) const override;

  virtual void SetMinPopSize(unsigned int _minpopsize) {
    minpopsize = _minpopsize;
  }

  unsigned int MinPopSize() const { return minpopsize; }

  /// return minimal population size for ADE
  unsigned int MinimalADEPopulationSize() const { return 2 + 2 * ndifferences; }

  /// set ADE initialization by a strategy name (e.g. "DE/rand/rand/1/bin")
  /*
   * return values:
   * 0  = success
   * -1 = strategy_name == 0
   * -2 = wrong format
   * -4 = unknown field contents
   */
  int SetStrategy(const std::string &strategyname = "DE/rand/rand/1/acm");

  /// return strategy name
  std::string ComposeStrategyName() const;

  virtual int Print(FILE *stream = stdout) const override;
};

} // namespace asyncde

#endif
